-- @nsURI TOSCA=http://tosca4cloudify/1.0
-- @nsURI DDSM=http://ddsm/1.0
-- @atlcompiler emftvm

module ddsm2tosca;
create tosca : TOSCA from ddsm : DDSM;

rule DDSM2TOSCA{	
	from 
		s: DDSM!DDSM
	using{
		additionalNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement
			-> select(element | element.oclIsTypeOf(DDSM!VM))
			-> select(vm | vm.publicPorts.size() > 0)
			-> collect(frontendVm | thisModule.getFloatingIpNodeFromFrontend(frontendVm.elementId, frontendVm.publicPorts)).flatten();
		zookeeperServers: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!ZookeeperServer))
			-> collect(element | thisModule.getZookeeperServerNodeTemplate(element)).flatten();
		zookeeperQuorumNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!ZookeeperQuorum))
			-> collect(element | thisModule.getZookeeperQuorumNodeTemplate(element)).flatten();
		zookeeperCluster: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!ZookeeperCluster))
			-> collect(element | thisModule.getZookeeperCluster(element)).flatten();
		nimbusNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!Nimbus))
			-> collect(element | thisModule.getNimbusNodeTemplate(element)).flatten();
		supervisorNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!Supervisor))
			-> collect(element | thisModule.getStormSupervisorNodeTemplate(element)).flatten();
		stormClusters: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!StormCluster))
			-> collect(element | thisModule.getStormCluster(element)).flatten();
		sparkMasterNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!SparkMaster))
			-> collect(element | thisModule.getSparkMasterNodeTemplate(element)).flatten();
		sparkWorkerNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!SparkWorker))
			-> collect(element | thisModule.getSparkWorkerNodeTemplate(element)).flatten();
		sparkClusters: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!SparkCluster))
			-> collect(element | thisModule.getSparkCluster(element)).flatten();
		cassandraSeeds: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!CassandraSeed))
			-> collect(element | thisModule.getSeedNodeTemplate(element)).flatten();
		cassandraWorkers: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!CassandraWorker))
			-> collect(element | thisModule.getCassandraWorkerNodeTemplate(element)).flatten();
		cassandraClusters: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!CassandraCluster))
			-> collect(element | thisModule.getCassandraCluster(element)).flatten();
		storm_clients: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!ClientNode))
			-> collect(element | thisModule.getStormClientNodeTemplate(element)).flatten();
	}
	to 
		t: TOSCA!TopologyTemplate(
			tosca_definitions_version <- 'cloudify_dsl_1_2',
			
			description <- s.description,
					
			nodeTemplates <- s.cloudelement 
			-> select(element | element.oclIsKindOf(DDSM!VM))
			-> collect(element | thisModule.getNodeTemplatesFromVM(element)).
			union(s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!InternalComponent))
			-> collect(element | thisModule.getNodeTemplatesFromInternalComponent(element))).
			union(zookeeperServers).
			union(zookeeperQuorumNodes).
			union(nimbusNodes).
			union(supervisorNodes).
			union(stormClusters).
			union(sparkMasterNodes).
			union(sparkWorkerNodes).
			union(sparkClusters).
			union(zookeeperCluster).
			union(cassandraSeeds).
			union(cassandraWorkers).
			union(cassandraClusters).
			union(storm_clients),
			
			imports <- DDSM!Provider.allInstances() -> collect(p | thisModule.getProviderImport(p))
		)
}

lazy rule getProviderImport {
	from
		p: DDSM!Provider
	to
		i: TOSCA!Import (
			file <-	'http://dice-project.github.io/DICE-Deployment-Cloudify/spec/' + p.type.toString().replaceAll('#','').toLower() + '/develop/plugin.yaml'
		)
}

-------------------- Client rules --------------------
rule getStormClientNodeTemplate (s: DDSM!ClientNode) {
    using {
		application: Sequence(TOSCA!Property) = thisModule.getPropertyFromStringAttribute('application', s.submits.artifactUrl);
		topology_name: Sequence(TOSCA!Property) = thisModule.getPropertyFromStringAttribute('topology_name', s.submits.elementId);
		topology_class: Sequence(TOSCA!Property) = thisModule.getPropertyFromStringAttribute('topology_class', s.submits.mainClass);
    	application_arguments: Sequence(TOSCA!Property) = thisModule.getPropertyFromStringAttribute('application_arguments', s.submits.applicationArguments);
    	storm_client_properties: Sequence(TOSCA!Property) = Sequence{application, topology_name, topology_class}.flatten();
	}
	to
		t: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,
			type <- 'dice.components.storm.Topology',
			 
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)).
				union(storm_client_properties),
				
			relationships <- s.requiredexecutionplatform -> 
				collect(platform |  
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 
						binding.requiredexecutionplatform.elementId = platform.elementId and
						binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!Nimbus)
					)
				) -> flatten() ->
				collect( binding | 
					thisModule.getStormClientRelationshipsFromExecutionBindingWithNimbus(
						binding.providedexecutionplatform.owner
					)
				) -> flatten()
				.union(
					s.requiredexecutionplatform -> 
						collect(platform |  
							DDSM!ExecutionBinding.allInstances() ->  
							select(binding | 
								binding.requiredexecutionplatform.elementId = platform.elementId and
								binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!StormCluster)
							)
						) -> flatten() ->
						collect( binding |
							thisModule.getStormClientRelationshipsFromExecutionBindingWithStormCluster(
								binding.providedexecutionplatform.owner
							)
						) -> flatten()
				)

		)
	do {
		Sequence{t};
	}
}

rule getStormClientRelationshipsFromExecutionBindingWithStormCluster(s: DDSM!StormCluster) {
	using {
		supervisor_bindings: Sequence(DDSM!ExecutionBinding) = s.requiresSlaveVm ->  
			collect(platform | 
				DDSM!ExecutionBinding.allInstances() -> 
				select(binding | 
					binding.requiredexecutionplatform.elementId = platform.elementId and
					binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM)
				)
			) -> flatten();
	
		client_to_storms: Sequence(TOSCA!Relationship) = supervisor_bindings -> collect(
			binding | thisModule.getClientToStormRelationship(s.elementId + '_' + binding.providedexecutionplatform.owner.elementId + '_supervisor')
		);
	}
	to
		client_to_nimbus: TOSCA!Relationship(
			target <- s.elementId + '_nimbus',
			type <- 'dice.relationships.storm.SubmittedBy'
		)
	do {
		Sequence{client_to_nimbus, client_to_storms};
	}
}

rule getStormClientRelationshipsFromExecutionBindingWithNimbus(s: DDSM!Nimbus) {
	using {
		required_supervisors: Sequence(DDSM!Supervisor) = DDSM!Supervisor.allInstances() ->  select(supervisor | 
			supervisor.hasMaster.elementId = s.elementId
		);
		client_to_storms: Sequence(TOSCA!Relationship) = required_supervisors -> 
			collect(supervisor | 
				thisModule.getClientToStormRelationship(supervisor.elementId)
			);
	}
	to
		client_to_nimbus: TOSCA!Relationship(
			target <- s.elementId,
			type <- 'dice.relationships.storm.SubmittedBy'
		)
	do {
		Sequence{client_to_nimbus, client_to_storms};
	}
}

lazy rule getClientToStormRelationship {
	from 
		s: String
	to 
		t: TOSCA!Relationship (
			target <- s,
			type <- 'dice.relationships.Needs'	
		)
}
-------------------- Client rules --------------------

-------------------- Zookeeper rules --------------------

rule getZookeeperCluster ( zookeeperCluster: DDSM!ZookeeperCluster) {
	using {
		peers_exec_bindings: Sequence(DDSM!ExecutionBinding) = zookeeperCluster.requiresPeerVm -> collect(peer_required_platform |  DDSM!ExecutionBinding.allInstances() -> 
			select(binding | binding.requiredexecutionplatform.elementId = peer_required_platform.elementId 
				and binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM))) -> flatten();
	
		peers: Sequence(TOSCA!NodeTemplate) = peers_exec_bindings -> collect(binding | 
			thisModule.getPeerNodeTemplateForZookeeperCluster(binding.providedexecutionplatform.owner, zookeeperCluster)) -> flatten();
	}
	to
		quorum: TOSCA!NodeTemplate (
			node_template_name <- zookeeperCluster.elementId,	
			type <- 'dice.components.zookeeper.Quorum', 
			
			properties <- zookeeperCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			relationships <- zookeeperCluster.requiresPeerVm -> collect(platform | DDSM!ExecutionBinding.allInstances() ->
			select(binding | binding.requiredexecutionplatform.elementId = platform.elementId)
			) -> flatten() -> collect(binding | thisModule.getZookeeperQuorumContainsRelationshipForZookeeperCluster(binding.providedexecutionplatform.owner.elementId)) -> flatten()
			.union(
				zookeeperCluster.requiredport -> collect( port | 
				thisModule.getConnectedToRelationshipFromRelationship(DDSM!Relationship.allInstances() ->  any(relationship | 
				relationship.requiredport.elementId = port.elementId
			))))
		)
	do {
		Sequence{peers, quorum};
	}
}

rule getZookeeperQuorumContainsRelationshipForZookeeperCluster(targ: String) {
	to
		t: TOSCA!Relationship (
			target <- targ,

			type <- 'dice.relationships.zookeeper.QuorumContains'
		)
	do {
		Sequence{t};
	}
}

rule getPeerNodeTemplateForZookeeperCluster (host: DDSM!VM, zookeeperCluster: DDSM!ZookeeperCluster) {
	to
		zookeeper_peer: TOSCA!NodeTemplate(
			node_template_name <- zookeeperCluster.elementId + '_' + host.elementId + '_worker',	
			type <- 'dice.components.zookeeper.Server', 
			
			properties <- zookeeperCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			relationships <- thisModule.getZookeeperServerRelationshipForZookeeperCluster(host, zookeeperCluster).
			union(
				zookeeperCluster.requiredport -> collect( port | 
				thisModule.getConnectedToRelationshipFromRelationship(DDSM!Relationship.allInstances() ->  any(relationship | 
				relationship.requiredport.elementId = port.elementId
			)))),
			
			configurations <- thisModule.getConfigurationFromAttribute('tickTime', 1500).union(
			thisModule.getConfigurationFromAttribute('initLimit', 10)).union(
			thisModule.getConfigurationFromAttribute('syncLimit', 5))
		),
		
		zookeeper_peer_firewall: TOSCA!NodeTemplate(
			node_template_name <- zookeeperCluster.elementId + '_' + host.elementId + '_worker_firewall',	
			type <- 'dice.firewall_rules.zookeeper.Server'
		)
	do {
		Sequence{zookeeper_peer, zookeeper_peer_firewall};
	}
}

rule getZookeeperServerRelationshipForZookeeperCluster(host: DDSM!VM, zookeeperCluster: DDSM!ZookeeperCluster) {
	to
		zookeeper_to_host: TOSCA!Relationship(
			target <- host.elementId,
			type <- 'dice.relationships.ContainedIn'
		),
		zookeeper_to_quorum: TOSCA!Relationship(
			target <- zookeeperCluster.elementId,
			type <- 'dice.relationships.zookeeper.MemberOfQuorum'
		)
	do {
		Sequence{zookeeper_to_host, zookeeper_to_quorum};
	}
}

lazy rule getZookeeperServerNodeTemplate {
	from
		s: DDSM!ZookeeperServer
	to
		server: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,	
			type <- 'dice.components.zookeeper.Server', 
			
			relationships <- s.requiredexecutionplatform -> collect( platform | 
			thisModule.getContainedInRelationshipFromExecutionBinding(DDSM!ExecutionBinding.allInstances() ->  any(binding | 		
			binding.requiredexecutionplatform.elementId = platform.elementId
			))).union(
				s.requiredport -> collect( port | 
				thisModule.getConnectedToRelationshipFromRelationship(DDSM!Relationship.allInstances() ->  any(relationship | 
				relationship.requiredport.elementId = port.elementId
			)))).union(
				thisModule.getZookeeperMemberOfQuorumRelationship(s)
			),
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('tickTime', s.tickTime).union(
			thisModule.getConfigurationFromAttribute('initLimit', s.initLimit)).union(
			thisModule.getConfigurationFromAttribute('syncLimit', s.syncLimit)),
			
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			)	
		),
		
		zookeeper_server_firewall: TOSCA!NodeTemplate(
			node_template_name <- s.elementId + '_firewall',	
			type <- 'dice.firewall_rules.zookeeper.Server'
		)
	do {
		Sequence{server, zookeeper_server_firewall};
	}
}

lazy rule getZookeeperQuorumNodeTemplate {
	from
		s: DDSM!ZookeeperQuorum
	to
		quorum: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,	
			type <- 'dice.components.zookeeper.Quorum', 
			
			relationships <- 
				DDSM!ZookeeperServer.allInstances() -> 
					select(server | 
						server.belongsToQuorum.elementId = s.elementId
					) -> 
					collect( server | 
						server.requiredexecutionplatform ->
							collect(platform | 
								DDSM!ExecutionBinding.allInstances() ->
									select(binding | 
										binding.requiredexecutionplatform.elementId = platform.elementId and 
										binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM)
									)	
							) -> flatten()
					) -> flatten() ->
					collect(binding |
						thisModule.getZookeeperQuorumContainsRelationship(binding)
					)
		)
}

lazy rule getZookeeperQuorumContainsRelationship {
	from
		s: DDSM!ExecutionBinding
	to
		t: TOSCA!Relationship (
			--relationship_name <- s.elementId + '_quorum',
			target <- s.providedexecutionplatform.owner.elementId,
			type <- 'dice.relationships.zookeeper.QuorumContains'
		)
}

lazy rule getZookeeperMemberOfQuorumRelationship {
	from
		s: DDSM!ZookeeperServer
	to
		t: TOSCA!Relationship (
			target <- s.belongsToQuorum.elementId,
			type <- 'dice.relationships.zookeeper.MemberOfQuorum'
		)
	do {
		Sequence{t};
	}
}

-------------------- Zookeeper rules --------------------

-------------------- Cassandra rules --------------------

lazy rule getSeedNodeTemplate{
	from
		s: DDSM!CassandraSeed
	to	
		seed: TOSCA!NodeTemplate(
			node_template_name <- s.elementId,
			type <- 'dice.components.cassandra.Seed',
			
			relationships <- s.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
					s.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredexecutionplatform.elementId = port.elementId
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				),
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property))
			
		),
		
		seed_firewall: TOSCA!NodeTemplate(
			node_template_name <- s.elementId + '_firewall',
			type <- 'dice.firewall_rules.cassandra.Common'
		)	
	do {
		Sequence{seed, seed_firewall};
	}	
}


lazy rule getCassandraWorkerNodeTemplate {
	from
		w: DDSM!CassandraWorker
	to
		worker: TOSCA!NodeTemplate(
			node_template_name <- w.elementId,
			type <- 'dice.components.cassandra.Worker',
			
			relationships <- w.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
					w.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredport.elementId = port.elementId
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				)
				.union(
					thisModule.getWorkerToSeedRelationship(w)
				),
			
			properties <- w.property 
			-> collect(property | thisModule.getProperty(property))
		),
		
		worker_firewall: TOSCA!NodeTemplate(
			node_template_name <- w.elementId + '_firewall',
			type <- 'dice.firewall_rules.cassandra.Common'
		)	
	do {
		Sequence{worker, worker_firewall};
	}	
}

lazy rule getWorkerToSeedRelationship {
	from 
		s: DDSM!CassandraWorker
	to
		t: TOSCA!Relationship (
			target <- 
			if DDSM!Relationship.allInstances() ->one(relationship | relationship.requiredport.elementId = s.belongsToQuorum.requires_bootstrapping_seed.elementId and
					relationship.providedport.owner.oclIsTypeOf(DDSM!CassandraSeed)) 
			then 
			DDSM!Relationship.allInstances() ->select(relationship | 
					relationship.requiredport.elementId = s.belongsToQuorum.requires_bootstrapping_seed.elementId and
					relationship.providedport.owner.oclIsTypeOf(DDSM!CassandraSeed)
			).first().providedport.owner.elementId
			else 
				'error_no_relationship_connecting_to_a_seed'
			endif,
			
			type <- 'dice.relationships.cassandra.ConnectedToSeed'
		)
	do {
		Sequence{t};
	}
}

rule getCassandraCluster (cassandraCluster: DDSM!CassandraCluster){
	using {
		workers: Sequence(TOSCA!NodeTemplate) = 
			cassandraCluster.requiresPeerVm -> collect(worker_required_platform |  
				DDSM!ExecutionBinding.allInstances() -> select(binding | 
					binding.requiredexecutionplatform.elementId = worker_required_platform.elementId
					and binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM))) -> flatten() -> collect(binding 
						| thisModule.getWorkerNodeTemplateForCassandraCluster(binding.providedexecutionplatform.owner, cassandraCluster));
	}
	to
		seed: TOSCA!NodeTemplate (
			node_template_name <- cassandraCluster.elementId + '_seed',	
			type <- 'dice.components.cassandra.Seed', 
			
			relationships <- thisModule.getContainedInRelationshipForCassandraClusterSeed(cassandraCluster)
		)
	do {
		Sequence{seed, workers};
	}
}

rule getContainedInRelationshipForCassandraClusterSeed(cassandraCluster: DDSM!CassandraCluster) {
	to
		t: TOSCA!Relationship (
			target <- DDSM!ExecutionBinding.allInstances() -> any(binding |
				binding.requiredexecutionplatform.elementId = cassandraCluster.requiresPeerVm.first().elementId and
				binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM)).providedexecutionplatform.owner.elementId,
			
			type <- 'dice.relationships.ContainedIn'
		)
	do {
		Sequence{t};
	}
}

rule getWorkerNodeTemplateForCassandraCluster (host: DDSM!VM, cassandraCluster: DDSM!CassandraCluster) {
	to
		cassandra_worker: TOSCA!NodeTemplate(
			node_template_name <- cassandraCluster.elementId + '_' + host.elementId + '_worker',	
			type <- 'dice.components.cassandra.Worker', 
			
			relationships <- thisModule.getCassandraWorkerRelationshipForCassandraCluster(host, cassandraCluster)
		),
		
		worker_firewall: TOSCA!NodeTemplate(
			node_template_name <- cassandraCluster.elementId + '_' + host.elementId + '_worker' + '_firewall',
			type <- 'dice.firewall_rules.cassandra.Common'
		)	
	do {
		Sequence{cassandra_worker, worker_firewall};
	}
}

rule getCassandraWorkerRelationshipForCassandraCluster(host: DDSM!VM, cassandraCluster: DDSM!CassandraCluster) {
	to
		worker_to_host: TOSCA!Relationship(
			target <- host.elementId,
			type <- 'dice.relationships.ContainedIn'
		),
		worker_to_seed: TOSCA!Relationship(
			target <- cassandraCluster.elementId + '_seed',
			type <- 'dice.relationships.cassandra.ConnectedToSeed'
		)
	do {
		Sequence{worker_to_host, worker_to_seed};
	}
}

-------------------- Cassandra rules --------------------
-------------------- Spark rules --------------------

lazy rule getSparkCluster {
	from
		sparkCluster: DDSM!SparkCluster
	to 
		master: TOSCA!NodeTemplate (
			node_template_name <- sparkCluster.elementId,	
			type <- 'dice.components.spark.Master', 
			relationships <- Sequence{thisModule.getContainedInRelationshipFromExecutionBinding(DDSM!ExecutionBinding.allInstances() -> 
				any(binding | 
					binding.requiredexecutionplatform.elementId = sparkCluster.requiresMasterVm.elementId
				)
			)},
			
			properties <- sparkCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('driverMemory', 1).union(
			thisModule.getConfigurationFromAttribute('driverCores', 1)).union(
			thisModule.getConfigurationFromAttribute('maxResultSize', 1)).union(
			thisModule.getConfigurationFromAttribute('UIPort', 4040))
		),
		
		master_firewall: TOSCA!NodeTemplate(
			node_template_name <- sparkCluster.elementId + '_firewall',
			type <- 'dice.firewall_rules.spark.Master'
		)
	do {
		Sequence{master, master_firewall, sparkCluster.requiresSlaveVm -> 
			collect(slave_required_platform |  
				DDSM!ExecutionBinding.allInstances() -> 
				any(binding | 
					binding.requiredexecutionplatform.elementId = slave_required_platform.elementId
				)
			) -> 
			collect(binding | 
				thisModule.getWorkerNodeTemplateForSparkCluster(binding.providedexecutionplatform.owner, sparkCluster)
			)
		}.flatten();
	}
}

lazy rule getWorkerNodeTemplateForSparkCluster {
	from 
		host: DDSM!VM, 
		sparkCluster: DDSM!SparkCluster
	to
		worker: TOSCA!NodeTemplate(
			node_template_name <- sparkCluster.elementId + '_' + host.elementId + '_worker',	
			type <- 'dice.components.spark.Worker', 
			
			relationships <- thisModule.getSparkWorkerRelationshipForSparkCluster(host, sparkCluster),
			
			properties <- sparkCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('sparkExecutorMemory', 1)
		),
		
		spark_worker_firewall: TOSCA!NodeTemplate(
			node_template_name <- sparkCluster.elementId  + '_' + host.elementId + '_worker' + '_firewall',
			type <- 'dice.firewall_rules.spark.Worker'
		)		
	do {
		Sequence{worker	, spark_worker_firewall};
	}
}

lazy rule getSparkWorkerRelationshipForSparkCluster {
	from
		host: DDSM!VM,
		sparkCluster: DDSM!SparkCluster
	to
		worker_to_host: TOSCA!Relationship(
			target <- host.elementId,
			type <- 'dice.relationships.ContainedIn'
		),
		worker_to_master: TOSCA!Relationship(
			target <- sparkCluster.elementId,
			type <- 'dice.relationships.spark.ConnectedToMaster'
		)
	do {
		Sequence{worker_to_host, worker_to_master};
	}
}

lazy rule getSparkMasterNodeTemplate {
	from
		s: DDSM!SparkMaster
	to
		sparkMaster: TOSCA!NodeTemplate(
			node_template_name <- s.elementId,
			type <- 'dice.components.spark.Master',
			
			relationships <- s.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
 					s.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredport.elementId = port.elementId and
							not (relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or
								 relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				),
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('driverMemory', s.driverMemory).union(
			thisModule.getConfigurationFromAttribute('driverCores', s.driverCores)).union(
			thisModule.getConfigurationFromAttribute('maxResultSize', s.maxResultSize)).union(
			thisModule.getConfigurationFromAttribute('UIPort', s.UIPort))
		),
		
		spark_master_firewall: TOSCA!NodeTemplate(
			node_template_name <- s.elementId + '_firewall',
			type <- 'dice.firewall_rules.spark.Master'
		)		
	do {
		Sequence{sparkMaster, spark_master_firewall};
	}
}

lazy rule getSparkWorkerNodeTemplate {
	from
		s: DDSM!SparkWorker
	to
		sparkWorker: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,
			type <- 'dice.components.spark.Worker',
			
			relationships <- s.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
 					s.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredport.elementId = port.elementId
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				)
				.append(
					thisModule.getSparkWorkerHasMasterRelationship(s)
				),
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('sparkExecutorMemory', s.sparkExecutorMemory)
		),
		
		spark_worker_firewall: TOSCA!NodeTemplate(
			node_template_name <- s.elementId + '_firewall',
			type <- 'dice.firewall_rules.spark.Worker'
		)		
	do {
		Sequence{sparkWorker, spark_worker_firewall};
	}

}

lazy rule getSparkWorkerHasMasterRelationship {
	from
		s: DDSM!SparkWorker
	to
		t: TOSCA!Relationship (
			target <- s.hasMaster.elementId,
			type <- 'dice.relationships.spark.ConnectedToMaster'
		)
}

-------------------- Spark rules --------------------

-------------------- Storm rules --------------------

rule getStormCluster (stormCluster: DDSM!StormCluster) {
	using {
		slaves_exec_bindings: Sequence(DDSM!ExecutionBinding) = stormCluster.requiresSlaveVm -> collect(slave_required_platform |  DDSM!ExecutionBinding.allInstances() -> 
			any(binding | binding.requiredexecutionplatform.elementId = slave_required_platform.elementId));
		slaves: Sequence(TOSCA!NodeTemplate) = slaves_exec_bindings -> collect(binding | thisModule.getSupervisorNodeTemplateForStormCluster(binding.providedexecutionplatform.owner, stormCluster));
	}
	to 
		nimbus: TOSCA!NodeTemplate (
			node_template_name <- stormCluster.elementId,	
			type <- 'dice.components.storm.Nimbus', 
			relationships <- thisModule.getNimbusRelationshipForStormCluster(stormCluster).
			union(
				stormCluster.requiredport -> collect( port | 
					thisModule.getConnectedToZookeeperQuorumRelationship(DDSM!Relationship.allInstances() ->  
						any(relationship | 
							relationship.requiredport.elementId = port.elementId and 
							(relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or 
							relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
						)
					) 
				)
			),
			
			properties <- stormCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('taskTimeout', 30).union(
			thisModule.getConfigurationFromAttribute('supervisorTimeout', 60)).union(
			thisModule.getConfigurationFromAttribute('monitorFrequency', 10)).union(
			thisModule.getConfigurationFromAttribute('queueSize', 100000)).union(
			thisModule.getConfigurationFromAttribute('retryTimes', 5)).union(
			thisModule.getConfigurationFromAttribute('retryInterval', 2000)).union(
			thisModule.getConfigurationFromAttribute('workerStartTimeout', 120)).union(
			thisModule.getConfigurationFromAttribute('heartbeatFrequency', 5)).union(
			thisModule.getConfigurationFromAttribute('cpuCapacity', 400)).union(
			thisModule.getConfigurationFromAttribute('memoryCapacity', 4096))
		),
		
		nimbus_firewall: TOSCA!NodeTemplate(
			node_template_name <- stormCluster.elementId + '_firewall',
			type <- 'dice.firewall_rules.storm.Nimbus'
		)		
	do {
		Sequence{nimbus, nimbus_firewall, slaves};
	}
}

rule getSupervisorNodeTemplateForStormCluster(host: DDSM!VM, stormCluster: DDSM!StormCluster) {
	to
		supervisor: TOSCA!NodeTemplate(
			node_template_name <- stormCluster.elementId + '_' + host.elementId + '_slave',	
			type <- 'dice.components.storm.Worker', 
			
			relationships <- thisModule.getSupervisorRelationshipForStormCluster(host, stormCluster).
			union(
				stormCluster.requiredport -> collect( port | 
					thisModule.getConnectedToZookeeperQuorumRelationship(DDSM!Relationship.allInstances() ->  
						any(relationship | 
							relationship.requiredport.elementId = port.elementId and 
							(relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or 
							relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
						)
					)
				) 
			),
			
			properties <- stormCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('workerStartTimeout', 120).union(
			thisModule.getConfigurationFromAttribute('heartbeatFrequency', 5)).union(
			thisModule.getConfigurationFromAttribute('cpuCapacity', 400)).union(
			thisModule.getConfigurationFromAttribute('memoryCapacity', 4096))	
		)
	do {
		supervisor;
	}
}

lazy rule getConnectedToZookeeperQuorumRelationship {
	from
		s:  DDSM!Relationship
	to
		t: TOSCA!Relationship(
			target <- s.providedport.owner.elementId,
			type <- 'dice.relationships.storm.ConnectedToZookeeperQuorum'
		)
}

rule getSupervisorRelationshipForStormCluster(host: DDSM!VM, stormCluster: DDSM!StormCluster) {
	to
		supervisor_to_host: TOSCA!Relationship(
			target <- host.elementId,
			type <- 'dice.relationships.ContainedIn'
		),
		supervisor_to_nimbus: TOSCA!Relationship(
			target <- stormCluster.elementId,
			type <- 'dice.relationships.storm.ConnectedToNimbus'
		)
	do {
		Sequence{supervisor_to_host, supervisor_to_nimbus};
	}
}

rule getNimbusRelationshipForStormCluster(stormCluster: DDSM!StormCluster) {
	to
		nimbus_to_host: TOSCA!Relationship(
		    target <- (DDSM!ExecutionBinding.allInstances() -> 
				any(binding | binding.requiredexecutionplatform.elementId = stormCluster.requiresMasterVm.elementId)).providedexecutionplatform.owner.elementId,
			
			type <- 'dice.relationships.ContainedIn'
		)
	do {
		Sequence{nimbus_to_host};
	}
}

lazy rule getNimbusNodeTemplate {
	from
		s: DDSM!Nimbus
	to
		nimbus: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,	
			type <- 'dice.components.storm.Nimbus', 
			
			relationships <- s.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
 					s.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredport.elementId = port.elementId and
							not (relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or
								 relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				)
				.union(
					thisModule.getStormToZookeeperRelationship(s)
				)
			,
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('taskTimeout', s.taskTimeout).union(
			thisModule.getConfigurationFromAttribute('supervisorFrequency', s.supervisorFrequency)).union(
			thisModule.getConfigurationFromAttribute('monitorFrequency', s.monitorFrequency)).union(
			thisModule.getConfigurationFromAttribute('queueSize', s.queueSize)).union(
			thisModule.getConfigurationFromAttribute('retryTimes', s.retryTimes)).union(
			thisModule.getConfigurationFromAttribute('retryInterval', s.retryInterval)).union(
			thisModule.getConfigurationFromAttribute('workerStartTimeout', s.workerStartTimeout)).union(
			thisModule.getConfigurationFromAttribute('heartbeatFrequency', s.heartbeatFrequency)).union(
			thisModule.getConfigurationFromAttribute('cpuCapacity', s.cpuCapacity)).union(
			thisModule.getConfigurationFromAttribute('memoryCapacity', s.memoryCapacity)),
			
			
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			)	
		),
		
		nimbus_firewall: TOSCA!NodeTemplate(
			node_template_name <- s.elementId + '_firewall',
			type <- 'dice.firewall_rules.storm.Nimbus'
		)		
	do {
		Sequence{nimbus, nimbus_firewall};
	}
}

lazy rule getStormToZookeeperRelationship {
	from 
		s: DDSM!Nimbus
	to
		t: TOSCA!Relationship (
			target <- 
			if DDSM!Relationship.allInstances() ->
			one(relationship | 
				s.requiredport ->
				one(port | 
					relationship.requiredport.elementId = port.elementId and
					(relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or
					relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
				)
			) 
			then 
			DDSM!Relationship.allInstances() ->
			select(relationship | 
				s.requiredport ->
				one(port | 
					relationship.requiredport.elementId = port.elementId and
					(relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or
					relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
				)
			).first().providedport.owner.elementId
			else 
				'error_no_relationship_connecting_to_a_zookeeper'
			endif,
			
			type <- 'dice.relationships.storm.ConnectedToZookeeperQuorum'
		)
	do {
		Sequence{t};
	}
}

lazy rule getStormSupervisorNodeTemplate {
	from
		s: DDSM!Supervisor
	to
		supervisor: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,	
			type <- 'dice.components.storm.Worker', 
			
			relationships <- s.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
 					s.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredport.elementId = port.elementId
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				)
				.union(
					thisModule.getSupervisorHasMasterRelationship(s)
				)				
				.union(
					thisModule.getStormToZookeeperRelationship(s.hasMaster)
				)
			,
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('workerStartTimeout', s.workerStartTimeout).union(
			thisModule.getConfigurationFromAttribute('heartbeatFrequency', s.heartbeatFrequency)).union(
			thisModule.getConfigurationFromAttribute('cpuCapacity', s.cpuCapacity)).union(
			thisModule.getConfigurationFromAttribute('memoryCapacity', s.memoryCapacity)),
			
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			)	
		)
}

lazy rule getSupervisorHasMasterRelationship {
	from
		s: DDSM!Supervisor
	to
		t: TOSCA!Relationship (
			target <- s.hasMaster.elementId,
			type <- 'dice.relationships.storm.ConnectedToNimbus'
		)
	do {
		Sequence{t};
	}
}

lazy rule getSupervisorToNimbusRelationship {
	from
		s: DDSM!Supervisor
	to
		t: TOSCA!Relationship (
			target <- s.hasMaster.elementId,
			type <- 'dice.relationships.storm.ConnectedToNimbus'
		)
	do {
		Sequence{t};
	}
}
-------------------- Storm rules --------------------

lazy rule getProvidedByRelationships {
	from
		s: String
	to
		t: TOSCA!Relationship (
			target <- s,
			type <- 'dice.relationships.ProtectedBy'
		)
		
}

lazy rule getNodeTemplatesFromVM{
	from
		s: DDSM!VM
	to
		t : TOSCA!NodeTemplate(
			node_template_name <- s.elementId,
            type <- s.getVMGenericSize, 
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),	
			
			instances <- thisModule.getInstancesElement(s.instances),
						
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			),
			
			relationships <- 
			DDSM!PeerToPeerPlatform.allInstances() -> 
			select( peer2peer | 
				peer2peer.requiresPeerVm ->
				exists(reqPlatform | 
					s.providedexecutionplatform ->
					exists(provPlatform | 
							DDSM!ExecutionBinding.allInstances() ->
							exists(binding | 
								binding.requiredexecutionplatform.elementId = reqPlatform.elementId and
								binding.providedexecutionplatform.elementId = provPlatform.elementId
							)
					)
				)
			) ->
			collect(peer2peer | thisModule.getProvidedByRelationships(peer2peer.elementId + '_' + s.elementId + '_worker_firewall'))
			.union(
				DDSM!CassandraSeed.allInstances().asSequence()
				.union(
				DDSM!Nimbus.allInstances().asSequence()
				).union(
				DDSM!CassandraWorker.allInstances().asSequence()
				).union(
				DDSM!ZookeeperServer.allInstances().asSequence()
				).union(
				DDSM!SparkMaster.allInstances().asSequence()
				).union(
				DDSM!SparkWorker.allInstances().asSequence()
				) -> 
				select(comp | 
					comp.requiredexecutionplatform ->
					exists(reqPlatform | 
						s.providedexecutionplatform ->
						exists(provPlatform | 
								DDSM!ExecutionBinding.allInstances() ->
								exists(binding | 
									binding.requiredexecutionplatform.elementId = reqPlatform.elementId and
									binding.providedexecutionplatform.elementId = provPlatform.elementId
								)
						)
					)
					
				) ->
				collect(comp | thisModule.getProvidedByRelationships(comp.elementId + '_firewall'))					
			)
			.union(
				DDSM!MasterSlavePlatform.allInstances() -> 
				select(masterslave | 
					s.providedexecutionplatform ->
					exists(provPlatform | 
							DDSM!ExecutionBinding.allInstances() ->
							exists(binding | 
								binding.requiredexecutionplatform.elementId = masterslave.requiresMasterVm.elementId and
								binding.providedexecutionplatform.elementId = provPlatform.elementId
							)
					)
				) ->
				collect(masterslave | thisModule.getProvidedByRelationships(masterslave.elementId + '_firewall'))
			)			
		)
}

lazy rule getInstancesElement{
	from
		nInstances: Integer
	to
		instances_element: TOSCA!Instances(
			deploy <- nInstances	
		)
	do {
		instances_element;
	}
}

lazy rule getNodeTemplatesFromInternalComponent{
	from 
		s : DDSM!InternalComponent
	to
		t : TOSCA!NodeTemplate(
			node_template_name <- s.elementId,	
			type <- 'dice.' + s.oclType().refGetValue('name').toString().toLower(), 
			
			relationships <- s.requiredexecutionplatform -> collect( platform | 
			thisModule.getContainedInRelationshipFromExecutionBinding(DDSM!ExecutionBinding.allInstances() ->  any(binding | 
			binding.requiredexecutionplatform.elementId = platform.elementId
			))).union(
				s.requiredport -> collect( port | 
				thisModule.getConnectedToRelationshipFromRelationship(DDSM!Relationship.allInstances() ->  any(relationship | 
				relationship.requiredport.elementId = port.elementId
			)))),
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			)	
		)
		
}

lazy rule getContainedInRelationshipFromExecutionBinding{
	from
		s:  DDSM!ExecutionBinding
	to
		t: TOSCA!Relationship(
			target <- s.providedexecutionplatform.owner.elementId,
			type <- 'dice.relationships.ContainedIn',
			source_interfaces <- s.requiredexecutionplatform.resource 
			-> collect(resource | thisModule.getInterfaceFromResource(resource)),
			target_interfaces <- s.providedexecutionplatform.resource 
			-> collect(resource | thisModule.getInterfaceFromResource(resource)),
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property))
		)
}

lazy rule getConnectedToRelationshipFromRelationship {
	from
		s:  DDSM!Relationship
	to
		t: TOSCA!Relationship(
			target <- s.providedport.owner.elementId,
			type <- 'dice.relationships.ConnectedTo',
			source_interfaces <- s.requiredport.resource 
			-> collect(resource | thisModule.getInterfaceFromResource(resource)),
			target_interfaces <- s.providedport.resource 
			-> collect(resource | thisModule.getInterfaceFromResource(resource)),
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property))
		)
		
}

helper context DDSM!VM def: getVMGenericSize: String =
	if not self.genericSize.oclIsUndefined() then
		'dice.hosts.' + self.genericSize.toString().replaceAll('#', '')
	else
		'dice.hosts.GenericHost'
	endif;

lazy rule getProperty{
	from 
		s : DDSM!Property
	to
		t : TOSCA!Property(
			property_name <- s.propertyId,
			value <- s.value
		)
}

rule getPropertyFromAttribute(name: String, value: Integer){
	to
		t : TOSCA!Property(
			property_name <- name,
			value <- value.toString()
		)
	do {
		Sequence{t};
	}
}

rule getConfigurationFromAttribute(name: String, value: Integer){
	to
		t : TOSCA!Configuration(
			property_name <- name,
			value <- value.toString()
		)
	do {
		Sequence{t};
	}
}

rule getPropertyFromStringAttribute(name: String, value: String){
	to
		t : TOSCA!Property(
			property_name <- name,
			value <- value.toString()
		)
	do {
		Sequence{t};
	}
}
