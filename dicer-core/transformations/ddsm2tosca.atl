-- @nsURI TOSCA=http://tosca4cloudify/1.0
-- @nsURI DDSM=http://ddsm/1.0
-- @atlcompiler emftvm

module ddsm2tosca;
create tosca : TOSCA from ddsm : DDSM;

rule DDSM2TOSCA{	
	from 
		s: DDSM!DDSM
	using{
		flexiantImports: Sequence(TOSCA!Import) = thisModule.getFlexiantImport();
		additionalNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement
			-> select(element | element.oclIsTypeOf(DDSM!VM))
			-> select(vm | vm.publicPorts.size() > 0)
			-> collect(frontendVm | thisModule.getFloatingIpNodeFromFrontend(frontendVm.elementId, frontendVm.publicPorts)).flatten();
		zookeeperServers: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!ZookeeperServer))
			-> collect(element | thisModule.getZookeeperServerNodeTemplate(element));
		zookeeperQuorumNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!ZookeeperQuorum))
			-> collect(element | thisModule.getZookeeperQuorumNodeTemplate(element));
		zookeeperCluster: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!ZookeeperCluster))
			-> collect(element | thisModule.getZookeeperCluster(element)).flatten();
		nimbusNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!Nimbus))
			-> collect(element | thisModule.getNimbusNodeTemplate(element));
		supervisorNodes: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!Supervisor))
			-> collect(element | thisModule.getStormSupervisorNodeTemplate(element));
		stormCluster: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!StormCluster))
			-> collect(element | thisModule.getStormCluster(element)).flatten();
		cassandraSeeds: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!CassandraSeed))
			-> collect(element | thisModule.getSeedNodeTemplate(element));
		cassandraWorkers: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!CassandraWorker))
			-> collect(element | thisModule.getCassandraWorkerNodeTemplate(element));
		cassandraClusters: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!CassandraCluster))
			-> collect(element | thisModule.getCassandraCluster(element)).flatten();
		storm_clients: Sequence(TOSCA!NodeTemplate) = s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!ClientNode))
			-> collect(element | thisModule.getStormClientNodeTemplate(element)).flatten();
	}
	to 
		t: TOSCA!TopologyTemplate(
			tosca_definitions_version <- 'cloudify_dsl_1_1',
			
			description <- s.description,
					
			nodeTemplates <- s.cloudelement 
			-> select(element | element.oclIsKindOf(DDSM!VM))
			-> collect(element | thisModule.getNodeTemplatesFromVM(element)).
			union(s.cloudelement 
			-> select(element | element.oclIsTypeOf(DDSM!InternalComponent))
			-> collect(element | thisModule.getNodeTemplatesFromInternalComponent(element))).
			union(zookeeperServers).
			union(zookeeperQuorumNodes).
			union(nimbusNodes).
			union(supervisorNodes).
			union(stormCluster).
			union(zookeeperCluster).
			union(cassandraSeeds).
			union(cassandraWorkers).
			union(cassandraClusters).
			union(storm_clients)
		)
	do {
		for (p in DDSM!Provider.allInstances() ){
		
			if (p.isFlexiant()) {
				t.imports <- flexiantImports;
			}
		}	
				
	}
}


-------------------- Client rules --------------------
rule getStormClientNodeTemplate (s: DDSM!ClientNode) {
    using {
		application: Sequence(TOSCA!Property) = thisModule.getPropertyFromStringAttribute('application', s.submits.artifactUrl);
		topology_name: Sequence(TOSCA!Property) = thisModule.getPropertyFromStringAttribute('topology_name', s.submits.elementId);
		topology_class: Sequence(TOSCA!Property) = thisModule.getPropertyFromStringAttribute('topology_class', s.submits.mainClass);
    	storm_client_properties: Sequence(TOSCA!Property) = Sequence{application, topology_name, topology_class}.flatten();
	}
	to
		t: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,
			type <- 'dice.components.storm.Topology',
			 
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)).
				union(storm_client_properties),
				
			relationships <- s.requiredexecutionplatform -> 
				collect(platform |  
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 
						binding.requiredexecutionplatform.elementId = platform.elementId and
						binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!Nimbus)
					)
				) -> flatten() ->
				collect( binding | 
					thisModule.getStormClientRelationshipsFromExecutionBindingWithNimbus(
						binding.providedexecutionplatform.owner
					)
				) -> flatten()
				.union(
					s.requiredexecutionplatform -> 
						collect(platform |  
							DDSM!ExecutionBinding.allInstances() ->  
							select(binding | 
								binding.requiredexecutionplatform.elementId = platform.elementId and
								binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!StormCluster)
							)
						) -> flatten() ->
						collect( binding |
							thisModule.getStormClientRelationshipsFromExecutionBindingWithStormCluster(
								binding.providedexecutionplatform.owner
							)
						) -> flatten()
				)

		)
	do {
		Sequence{t};
	}
}

rule getStormClientRelationshipsFromExecutionBindingWithStormCluster(s: DDSM!StormCluster) {
	using {
		supervisor_bindings: Sequence(DDSM!ExecutionBinding) = s.requiresSlaveVm ->  
			collect(platform | 
				DDSM!ExecutionBinding.allInstances() -> 
				select(binding | 
					binding.requiredexecutionplatform.elementId = platform.elementId and
					binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM)
				)
			) -> flatten();
	
		client_to_storms: Sequence(TOSCA!Relationship) = supervisor_bindings -> collect(
			binding | thisModule.getClientToStormRelationship(s.elementId + '_' + binding.providedexecutionplatform.owner.elementId + '_supervisor')
		);
	}
	to
		client_to_nimbus: TOSCA!Relationship(
			target <- s.elementId + '_nimbus',
			type <- 'dice.relationships.storm.SubmittedBy'
		)
	do {
		Sequence{client_to_nimbus, client_to_storms};
	}
}

rule getStormClientRelationshipsFromExecutionBindingWithNimbus(s: DDSM!Nimbus) {
	using {
		required_supervisors: Sequence(DDSM!Supervisor) = DDSM!Supervisor.allInstances() ->  select(supervisor | 
			supervisor.hasMaster.elementId = s.elementId
		);
		client_to_storms: Sequence(TOSCA!Relationship) = required_supervisors -> 
			collect(supervisor | 
				thisModule.getClientToStormRelationship(supervisor.elementId)
			);
	}
	to
		client_to_nimbus: TOSCA!Relationship(
			target <- s.elementId,
			type <- 'dice.relationships.storm.SubmittedBy'
		)
	do {
		Sequence{client_to_nimbus, client_to_storms};
	}
}

lazy rule getClientToStormRelationship {
	from 
		s: String
	to 
		t: TOSCA!Relationship (
			target <- s,
			type <- 'dice.relationships.Needs'	
		)
}
-------------------- Client rules --------------------

-------------------- Zookeeper rules --------------------

rule getZookeeperCluster ( zookeeperCluster: DDSM!ZookeeperCluster) {
	using {
		peers_exec_bindings: Sequence(DDSM!ExecutionBinding) = zookeeperCluster.requiresPeerVm -> collect(peer_required_platform |  DDSM!ExecutionBinding.allInstances() -> 
			select(binding | binding.requiredexecutionplatform.elementId = peer_required_platform.elementId 
				and binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM))) -> flatten();
	
		peers: Sequence(TOSCA!NodeTemplate) = peers_exec_bindings -> collect(binding | 
			thisModule.getPeerNodeTemplateForZookeeperCluster(binding.providedexecutionplatform.owner, zookeeperCluster)) -> flatten();
	}
	to
		quorum: TOSCA!NodeTemplate (
			node_template_name <- zookeeperCluster.elementId + '_quorum',	
			type <- 'dice.components.zookeeper.Quorum', 
			
			properties <- zookeeperCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			relationships <- zookeeperCluster.requiresPeerVm -> collect(platform | DDSM!ExecutionBinding.allInstances() ->
			select(binding | binding.requiredexecutionplatform.elementId = platform.elementId)
			) -> flatten() -> collect(binding | thisModule.getZookeeperQuorumContainsRelationshipForZookeeperCluster(binding.providedexecutionplatform.owner.elementId)) -> flatten()
			.union(
				zookeeperCluster.requiredport -> collect( port | 
				thisModule.getConnectedToRelationshipFromRelationship(DDSM!Relationship.allInstances() ->  any(relationship | 
				relationship.requiredport.elementId = port.elementId
			))))
		)
	do {
		Sequence{peers, quorum};
	}
}

rule getZookeeperQuorumContainsRelationshipForZookeeperCluster(targ: String) {
	to
		t: TOSCA!Relationship (
			target <- targ,

			type <- 'dice.relationships.zookeeper.QuorumContains'
		)
	do {
		Sequence{t};
	}
}

rule getPeerNodeTemplateForZookeeperCluster (host: DDSM!VM, zookeeperCluster: DDSM!ZookeeperCluster) {
	to
		zookeeper_peer: TOSCA!NodeTemplate(
			node_template_name <- zookeeperCluster.elementId + '_' + host.elementId + '_server',	
			type <- 'dice.components.zookeeper.Server', 
			
			properties <- zookeeperCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			relationships <- thisModule.getZookeeperServerRelationshipForZookeeperCluster(host, zookeeperCluster).
			union(
				zookeeperCluster.requiredport -> collect( port | 
				thisModule.getConnectedToRelationshipFromRelationship(DDSM!Relationship.allInstances() ->  any(relationship | 
				relationship.requiredport.elementId = port.elementId
			)))),
			
			configurations <- thisModule.getConfigurationFromAttribute('tickTime', 1500).union(
			thisModule.getConfigurationFromAttribute('initLimit', 10)).union(
			thisModule.getConfigurationFromAttribute('syncLimit', 5))
		)
	do {
		zookeeper_peer;
	}
}

rule getZookeeperServerRelationshipForZookeeperCluster(host: DDSM!VM, zookeeperCluster: DDSM!ZookeeperCluster) {
	to
		zookeeper_to_host: TOSCA!Relationship(
			target <- host.elementId,
			type <- 'dice.relationships.ContainedIn'
		),
		zookeeper_to_quorum: TOSCA!Relationship(
			target <- zookeeperCluster.elementId + '_quorum',
			type <- 'dice.relationships.zookeeper.MemberOfQuorum'
		)
	do {
		Sequence{zookeeper_to_host, zookeeper_to_quorum};
	}
}

lazy rule getZookeeperServerNodeTemplate {
	from
		s: DDSM!ZookeeperServer
	to
		server: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,	
			type <- 'dice.components.zookeeper.Server', 
			
			relationships <- s.requiredexecutionplatform -> collect( platform | 
			thisModule.getContainedInRelationshipFromExecutionBinding(DDSM!ExecutionBinding.allInstances() ->  any(binding | 		
			binding.requiredexecutionplatform.elementId = platform.elementId
			))).union(
				s.requiredport -> collect( port | 
				thisModule.getConnectedToRelationshipFromRelationship(DDSM!Relationship.allInstances() ->  any(relationship | 
				relationship.requiredport.elementId = port.elementId
			)))).union(
				thisModule.getZookeeperMemberOfQuorumRelationship(s)
			),
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('tickTime', 1500).union(
			thisModule.getConfigurationFromAttribute('initLimit', 10)).union(
			thisModule.getConfigurationFromAttribute('syncLimit', 5)),
			
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			)	
		)
}

lazy rule getZookeeperQuorumNodeTemplate {
	from
		s: DDSM!ZookeeperQuorum
	to
		quorum: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,	
			type <- 'dice.components.zookeeper.Quorum', 
			
			relationships <- 
				DDSM!ZookeeperServer.allInstances() -> 
					select(server | 
						server.belongsToQuorum.elementId = s.elementId
					) -> 
					collect( server | 
						server.requiredexecutionplatform ->
							collect(platform | 
								DDSM!ExecutionBinding.allInstances() ->
									select(binding | 
										binding.requiredexecutionplatform.elementId = platform.elementId and 
										binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM)
									)	
							) -> flatten()
					) -> flatten() ->
					collect(binding |
						thisModule.getZookeeperQuorumContainsRelationship(binding)
					)
		)
}

lazy rule getZookeeperQuorumContainsRelationship {
	from
		s: DDSM!ExecutionBinding
	to
		t: TOSCA!Relationship (
			--relationship_name <- s.elementId + '_quorum',
			target <- s.providedexecutionplatform.owner.elementId,
			type <- 'dice.relationships.zookeeper.QuorumContains'
		)
}

lazy rule getZookeeperMemberOfQuorumRelationship {
	from
		s: DDSM!ZookeeperServer
	to
		t: TOSCA!Relationship (
			target <- s.belongsToQuorum.elementId,
			type <- 'dice.relationships.zookeeper.MemberOfQuorum'
		)
	do {
		Sequence{t};
	}
}

-------------------- Zookeeper rules --------------------

-------------------- Cassandra rules --------------------

lazy rule getSeedNodeTemplate{
	from
		s: DDSM!CassandraSeed
	to	
		t: TOSCA!NodeTemplate(
			node_template_name <- s.elementId,
			type <- 'dice.components.cassandra.Seed',
			
			relationships <- s.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
					s.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredexecutionplatform.elementId = port.elementId
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				),
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property))
			
		)	
}


lazy rule getCassandraWorkerNodeTemplate {
	from
		w: DDSM!CassandraWorker
	to
		t: TOSCA!NodeTemplate(
			node_template_name <- w.elementId,
			type <- 'dice.components.cassandra.Worker',
			
			relationships <- w.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
					w.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredport.elementId = port.elementId
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				)
				.union(
					thisModule.getWorkerToSeedRelationship(w)
				),
			
			properties <- w.property 
			-> collect(property | thisModule.getProperty(property))
		)
}

lazy rule getWorkerToSeedRelationship {
	from 
		s: DDSM!CassandraWorker
	to
		t: TOSCA!Relationship (
			target <- 
			if DDSM!Relationship.allInstances() ->one(relationship | relationship.requiredport.elementId = s.belongsToQuorum.requires_bootstrapping_seed.elementId and
					relationship.providedport.owner.oclIsTypeOf(DDSM!CassandraSeed)) 
			then 
			DDSM!Relationship.allInstances() ->select(relationship | 
					relationship.requiredport.elementId = s.belongsToQuorum.requires_bootstrapping_seed.elementId and
					relationship.providedport.owner.oclIsTypeOf(DDSM!CassandraSeed)
			).first().providedport.owner.elementId
			else 
				'error_no_relationship_connecting_to_a_seed'
			endif,
			
			type <- 'dice.relationships.cassandra.ConnectedToSeed'
		)
	do {
		Sequence{t};
	}
}

rule getCassandraCluster (cassandraCluster: DDSM!CassandraCluster){
	using {
		workers: Sequence(TOSCA!NodeTemplate) = 
			cassandraCluster.requiresPeerVm -> collect(worker_required_platform |  
				DDSM!ExecutionBinding.allInstances() -> select(binding | 
					binding.requiredexecutionplatform.elementId = worker_required_platform.elementId
					and binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM))) -> flatten() -> collect(binding 
						| thisModule.getWorkerNodeTemplateForCassandraCluster(binding.providedexecutionplatform.owner, cassandraCluster));
	}
	to
		seed: TOSCA!NodeTemplate (
			node_template_name <- cassandraCluster.elementId + '_seed',	
			type <- 'dice.components.cassandra.Seed', 
			
			relationships <- thisModule.getContainedInRelationshipForCassandraClusterSeed(cassandraCluster)
		)
	do {
		Sequence{seed, workers};
	}
}

rule getContainedInRelationshipForCassandraClusterSeed(cassandraCluster: DDSM!CassandraCluster) {
	to
		t: TOSCA!Relationship (
			target <- DDSM!ExecutionBinding.allInstances() -> any(binding |
				binding.requiredexecutionplatform.elementId = cassandraCluster.requiresPeerVm.first().elementId and
				binding.providedexecutionplatform.owner.oclIsTypeOf(DDSM!VM)).providedexecutionplatform.owner.elementId,
			
			type <- 'dice.relationships.ContainedIn'
		)
	do {
		Sequence{t};
	}
}

rule getWorkerNodeTemplateForCassandraCluster (host: DDSM!VM, cassandraCluster: DDSM!CassandraCluster) {
	to
		cassandra_worker: TOSCA!NodeTemplate(
			node_template_name <- cassandraCluster.elementId + '_' + host.elementId + '_worker',	
			type <- 'dice.components.cassandra.Worker', 
			
			relationships <- thisModule.getCassandraWorkerRelationshipForCassandraCluster(host, cassandraCluster)
		)
	do {
		cassandra_worker;
	}
}

rule getCassandraWorkerRelationshipForCassandraCluster(host: DDSM!VM, cassandraCluster: DDSM!CassandraCluster) {
	to
		worker_to_host: TOSCA!Relationship(
			target <- host.elementId,
			type <- 'dice.relationships.ContainedIn'
		),
		worker_to_seed: TOSCA!Relationship(
			target <- cassandraCluster.elementId + '_seed',
			type <- 'dice.relationships.cassandra.ConnectedToSeed'
		)
	do {
		Sequence{worker_to_host, worker_to_seed};
	}
}

-------------------- Cassandra rules --------------------

-------------------- Storm rules --------------------

rule getStormCluster (stormCluster: DDSM!StormCluster) {
	using {
		slaves_exec_bindings: Sequence(DDSM!ExecutionBinding) = stormCluster.requiresSlaveVm -> collect(slave_required_platform |  DDSM!ExecutionBinding.allInstances() -> 
			any(binding | binding.requiredexecutionplatform.elementId = slave_required_platform.elementId));
		slaves: Sequence(TOSCA!NodeTemplate) = slaves_exec_bindings -> collect(binding | thisModule.getSupervisorNodeTemplateForStormCluster(binding.providedexecutionplatform.owner, stormCluster));
	}
	to 
		nimbus: TOSCA!NodeTemplate (
			node_template_name <- stormCluster.elementId + '_nimbus',	
			type <- 'dice.components.storm.Nimbus', 
			relationships <- thisModule.getNimbusRelationshipForStormCluster(stormCluster).
			union(
				stormCluster.requiredport -> collect( port | 
					thisModule.getConnectedToZookeeperQuorumRelationship(DDSM!Relationship.allInstances() ->  
						any(relationship | 
							relationship.requiredport.elementId = port.elementId and 
							(relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or 
							relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
						)
					) 
				)
			),
			
			properties <- stormCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('taskTimeout', 30).union(
			thisModule.getConfigurationFromAttribute('supervisorTimeout', 60)).union(
			thisModule.getConfigurationFromAttribute('monitorFrequency', 10)).union(
			thisModule.getConfigurationFromAttribute('queueSize', 100000)).union(
			thisModule.getConfigurationFromAttribute('retryTimes', 5)).union(
			thisModule.getConfigurationFromAttribute('retryInterval', 2000)))		
	do {
		Sequence{nimbus, slaves};
	}
}

rule getSupervisorNodeTemplateForStormCluster(host: DDSM!VM, stormCluster: DDSM!StormCluster) {
	to
		supervisor: TOSCA!NodeTemplate(
			node_template_name <- stormCluster.elementId + '_' + host.elementId + '_supervisor',	
			type <- 'dice.components.storm.Worker', 
			
			relationships <- thisModule.getSupervisorRelationshipForStormCluster(host, stormCluster).
			union(
				stormCluster.requiredport -> collect( port | 
					thisModule.getConnectedToZookeeperQuorumRelationship(DDSM!Relationship.allInstances() ->  
						any(relationship | 
							relationship.requiredport.elementId = port.elementId and 
							(relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or 
							relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
						)
					)
				) 
			),
			
			properties <- stormCluster.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('workerStartTimeout', 120).union(
			thisModule.getConfigurationFromAttribute('heartbeatFrequency', 5)).union(
			thisModule.getConfigurationFromAttribute('cpuCapacity', 400)).union(
			thisModule.getConfigurationFromAttribute('memoryCapacity', 4096))	
		)
	do {
		supervisor;
	}
}

lazy rule getConnectedToZookeeperQuorumRelationship {
	from
		s:  DDSM!Relationship
	to
		t: TOSCA!Relationship(
			target <- s.providedport.owner.elementId,
			type <- 'dice.relationships.storm.ConnectedToZookeeperQuorum'
		)
}

rule getSupervisorRelationshipForStormCluster(host: DDSM!VM, stormCluster: DDSM!StormCluster) {
	to
		supervisor_to_host: TOSCA!Relationship(
			target <- host.elementId,
			type <- 'dice.relationships.ContainedIn'
		),
		supervisor_to_nimbus: TOSCA!Relationship(
			target <- stormCluster.elementId + '_nimbus',
			type <- 'dice.relationships.storm.ConnectedToNimbus'
		)
	do {
		Sequence{supervisor_to_host, supervisor_to_nimbus};
	}
}

rule getNimbusRelationshipForStormCluster(stormCluster: DDSM!StormCluster) {
	to
		nimbus_to_host: TOSCA!Relationship(
		    target <- (DDSM!ExecutionBinding.allInstances() -> 
				any(binding | binding.requiredexecutionplatform.elementId = stormCluster.requiresMasterVm.elementId)).providedexecutionplatform.owner.elementId,
			
			type <- 'dice.relationships.ContainedIn'
		)
	do {
		Sequence{nimbus_to_host};
	}
}

lazy rule getNimbusNodeTemplate {
	from
		s: DDSM!Nimbus
	to
		nimbus: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,	
			type <- 'dice.components.storm.Nimbus', 
			
			relationships <- s.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
 					s.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredport.elementId = port.elementId and
							not (relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or
								 relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				)
				.union(
					thisModule.getStormToZookeeperRelationship(s)
				)
			,
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('taskTimeout', 30).union(
			thisModule.getConfigurationFromAttribute('supervisorTimeout', 60)).union(
			thisModule.getConfigurationFromAttribute('monitorFrequency', 10)).union(
			thisModule.getConfigurationFromAttribute('queueSize', 100000)).union(
			thisModule.getConfigurationFromAttribute('retryTimes', 5)).union(
			thisModule.getConfigurationFromAttribute('retryInterval', 2000)),
			
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			)	
		)
}

lazy rule getStormToZookeeperRelationship {
	from 
		s: DDSM!Nimbus
	to
		t: TOSCA!Relationship (
			target <- 
			if DDSM!Relationship.allInstances() ->
			one(relationship | 
				s.requiredport ->
				one(port | 
					relationship.requiredport.elementId = port.elementId and
					(relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or
					relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
				)
			) 
			then 
			DDSM!Relationship.allInstances() ->
			select(relationship | 
				s.requiredport ->
				one(port | 
					relationship.requiredport.elementId = port.elementId and
					(relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperQuorum) or
					relationship.providedport.owner.oclIsTypeOf(DDSM!ZookeeperCluster))
				)
			).first().providedport.owner.elementId
			else 
				'error_no_relationship_connecting_to_a_zookeeper'
			endif,
			
			type <- 'dice.relationships.storm.ConnectedToZookeeperQuorum'
		)
	do {
		Sequence{t};
	}
}

lazy rule getStormSupervisorNodeTemplate {
	from
		s: DDSM!Supervisor
	to
		supervisor: TOSCA!NodeTemplate (
			node_template_name <- s.elementId,	
			type <- 'dice.components.storm.Worker', 
			
			relationships <- s.requiredexecutionplatform -> 
				collect(platform | 
					DDSM!ExecutionBinding.allInstances() ->  
					select(binding | 		
						binding.requiredexecutionplatform.elementId = platform.elementId
					)
				) -> flatten() -> 
				collect(binding | 
					thisModule.getContainedInRelationshipFromExecutionBinding(binding)
				)
				.union(
 					s.requiredport -> 
					collect(port | 
						DDSM!Relationship.allInstances() ->  
						select(relationship | 		
							relationship.requiredport.elementId = port.elementId
						)
					) -> flatten() -> 
					collect(relationship | 
						thisModule.getConnectedToRelationshipFromRelationship(relationship)
					)	
				)
				.union(
					thisModule.getSupervisorHasMasterRelationship(s)
				)				
				.union(
					thisModule.getStormToZookeeperRelationship(s.hasMaster)
				)
			,
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			configurations <- thisModule.getConfigurationFromAttribute('workerStartTimeout', 120).union(
			thisModule.getConfigurationFromAttribute('heartbeatFrequency', 5)).union(
			thisModule.getConfigurationFromAttribute('cpuCapacity', 400)).union(
			thisModule.getConfigurationFromAttribute('memoryCapacity', 4096)),
			
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			)	
		)
}

lazy rule getSupervisorHasMasterRelationship {
	from
		s: DDSM!Supervisor
	to
		t: TOSCA!Relationship (
			target <- s.hasMaster.elementId,
			type <- 'dice.relationships.storm.ConnectedToNimbus'
		)
	do {
		Sequence{t};
	}
}

lazy rule getSupervisorToNimbusRelationship {
	from
		s: DDSM!Supervisor
	to
		t: TOSCA!Relationship (
			target <- s.hasMaster.elementId,
			type <- 'dice.relationships.storm.ConnectedToNimbus'
		)
	do {
		Sequence{t};
	}
}
-------------------- Storm rules --------------------

rule getFloatingIpNodeFromFrontend (elementId: String, publicPorts: Sequence(Integer)) {
	using {
		securityProperties: Sequence(TOSCA!Property) = publicPorts ->
		collect(port | thisModule.getPropertyFromAttribute('port', port)).flatten();
	}
	to
		t: TOSCA!NodeTemplate(
			node_template_name <- elementId + '_virtual_ip',
			type <- 'dice.virtual_ip'
		),
		u: TOSCA!NodeTemplate(
			node_template_name <- elementId + '_firewall',
			type <- 'dice.firewall_rules.' + elementId, 
			properties <- securityProperties
		)
	do {
		Sequence{t,u};
	}
		
}

rule getSecutiryHostRelationships (vmId: String) {
	to 
		ip: TOSCA!Relationship(
			target <- vmId + '_virtual_ip',
			type <- 'dice.server_connected_to_virtual_ip'
		),
		sec: TOSCA!Relationship(
			target <- vmId + '_virtual_ip',
			type <- 'dice.server_connected_to_firewall'
		)
	do {
		Sequence{ip, sec};
	}
}

rule getNodeTemplatesFromVM(s: DDSM!VM){
	to
		t : TOSCA!NodeTemplate(
			node_template_name <- s.elementId,
            type <- s.getVMGenericSize, 
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),	
			
			instances <- thisModule.getInstancesElement(s.instances),
						
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			)
		)
	do {
		if (s.publicPorts.size() > 0) {
			t.relationships <- thisModule.getSecutiryHostRelationships(s.elementId);
		}
		t;
	}
}

lazy rule getInstancesElement{
	from
		nInstances: Integer
	to
		instances_element: TOSCA!Instances(
			deploy <- nInstances	
		)
	do {
		instances_element;
	}
}

lazy rule getNodeTemplatesFromInternalComponent{
	from 
		s : DDSM!InternalComponent
	to
		t : TOSCA!NodeTemplate(
			node_template_name <- s.elementId,	
			type <- 'dice.' + s.oclType().refGetValue('name').toString().toLower(), 
			
			relationships <- s.requiredexecutionplatform -> collect( platform | 
			thisModule.getContainedInRelationshipFromExecutionBinding(DDSM!ExecutionBinding.allInstances() ->  any(binding | 
			binding.requiredexecutionplatform.elementId = platform.elementId
			))).union(
				s.requiredport -> collect( port | 
				thisModule.getConnectedToRelationshipFromRelationship(DDSM!Relationship.allInstances() ->  any(relationship | 
				relationship.requiredport.elementId = port.elementId
			)))),
			
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property)),
			
			interfaces <- 
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!Resource))
			-> collect(resource | thisModule.getInterfaceFromResource(resource)).union(
			s.resource 
			-> select(resource | resource.oclIsTypeOf(DDSM!ChefResource))
			-> collect(chef_resource | thisModule.getInterfaceFromChefResource(chef_resource))
			)	
		)
		
}

lazy rule getContainedInRelationshipFromExecutionBinding{
	from
		s:  DDSM!ExecutionBinding
	to
		t: TOSCA!Relationship(
			target <- s.providedexecutionplatform.owner.elementId,
			type <- 'dice.relationships.ContainedIn',
			source_interfaces <- s.requiredexecutionplatform.resource 
			-> collect(resource | thisModule.getInterfaceFromResource(resource)),
			target_interfaces <- s.providedexecutionplatform.resource 
			-> collect(resource | thisModule.getInterfaceFromResource(resource)),
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property))
		)
}

lazy rule getConnectedToRelationshipFromRelationship {
	from
		s:  DDSM!Relationship
	to
		t: TOSCA!Relationship(
			target <- s.providedport.owner.elementId,
			type <- 'dice.relationships.ConnectedTo',
			source_interfaces <- s.requiredport.resource 
			-> collect(resource | thisModule.getInterfaceFromResource(resource)),
			target_interfaces <- s.providedport.resource 
			-> collect(resource | thisModule.getInterfaceFromResource(resource)),
			properties <- s.property 
			-> collect(property | thisModule.getProperty(property))
		)
		
}

helper context DDSM!Provider def: isFlexiant(): Boolean =
	if self.type = #Flexiant then
		true
	else
		false
	endif
;

rule getFlexiantImport(){
	using {
		FCO_CLIENT_PLUGIN_VERSION: String = '0.1.1';
		PLATFORM: String = 'fco';
		FCO_PLUGIN_VERSION: String = 'develop';
		CHEF_PLUGIN_VERSION: String = '1.3.2';
	}
	to 
		i1: TOSCA!Import(
			file <- 'http://www.getcloudify.org/spec/cloudify/3.3.1/types.yaml'
		),
		i2: TOSCA!Import(
			file <- 'http://dice-project.github.io/DICE-FCO-Plugin-Cloudify/' + FCO_CLIENT_PLUGIN_VERSION + '/plugin.yaml'
		),
		i3: TOSCA!Import(
			file <- 'http://dice-project.github.io/cloudify-chef-plugin/' + CHEF_PLUGIN_VERSION + '/plugin.yaml'
		),
		i4: TOSCA!Import(
			file <- 'http://dice-project.github.io/DICE-Deployment-Cloudify/spec/' + PLATFORM + '/' + FCO_PLUGIN_VERSION + '/plugin.yaml'
		)
	do {
		Sequence{i1,i2,i3,i4};	
	}
}

rule getOpenstackImport(){
	using {
		OPENSTACK_VERSION: String = '';
	}
	to 
		i1: TOSCA!Import(
			file <- 'openstack-example-import-1' + OPENSTACK_VERSION
		),
		i2: TOSCA!Import(
			file <- 'openstack-example-import-2' + OPENSTACK_VERSION
		)
	do {
		Sequence{i1,i2};	
	}
}

helper context DDSM!VM def: getVMGenericSize: String =
	if not self.genericSize.oclIsUndefined() then
		'dice.hosts.' + self.genericSize.toString().replaceAll('#', '')
	else
		'dice.hosts.GenericHost'
	endif;

lazy rule getProperty{
	from 
		s : DDSM!Property
	to
		t : TOSCA!Property(
			property_name <- s.propertyId,
			value <- s.value
		)
}

rule getPropertyFromAttribute(name: String, value: Integer){
	to
		t : TOSCA!Property(
			property_name <- name,
			value <- value.toString()
		)
	do {
		Sequence{t};
	}
}

rule getConfigurationFromAttribute(name: String, value: Integer){
	to
		t : TOSCA!Configuration(
			property_name <- name,
			value <- value.toString()
		)
	do {
		Sequence{t};
	}
}

rule getPropertyFromStringAttribute(name: String, value: String){
	to
		t : TOSCA!Property(
			property_name <- name,
			value <- value.toString()
		)
	do {
		Sequence{t};
	}
}
